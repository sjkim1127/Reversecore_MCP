# Reversecore_MCP v1.1 - Technical Decisions and Q&A

This document contains technical review answers and decisions for v1.1 development.

## Security Questions

### Q1: Path Traversal Defense - Path Validation Improvement

**Question**: Should we use `Path.is_relative_to()` (Python 3.9+) or `os.path.commonpath()` for path containment check?

**Answer**: Use `os.path.commonpath()` (Python 3.5+ compatible)

**Rationale**:
- More robust than `str.startswith()` - handles edge cases like `/app/workspace-attack`
- Works correctly with symlinks (after `resolve()`)
- Better cross-platform compatibility
- Python 3.5+ support (broader compatibility)

**Implementation**:
```python
try:
    common = os.path.commonpath([abs_path, workspace_path])
    is_in_workspace = common == str(workspace_path)
except ValueError:
    is_in_workspace = False  # Different drives on Windows
```

**Test Cases**:
- Symlink chain: `/app/workspace/symlink -> /etc/passwd` (should be blocked)
- Edge case: `/app/workspace-attack` (should be blocked)
- Valid path: `/app/workspace/sample.exe` (should pass)

### Q2: Symlink Chain Testing

**Question**: How to test symlink chains that point outside workspace?

**Answer**: Create test fixtures with symlinks in test setup

**Implementation**:
- Create symlink in test fixtures: `tests/fixtures/samples/symlink_to_passwd`
- Test that `validate_file_path()` correctly blocks it
- Verify `resolve(strict=True)` resolves symlink before validation

### Q3: Large File Testing

**Question**: Should we add memory profiling tests for 1GB/5GB files in v1.1?

**Answer**: **Basic tests in v1.1, detailed profiling in v1.2**

**Rationale**:
- Basic OOM test (1GB file) is sufficient for v1.1
- Detailed memory profiling adds CI time and complexity
- Streaming implementation is already tested with smaller files

**Implementation**:
- Generate 1GB test file in CI (not 5GB - too slow)
- Verify OOM doesn't occur
- Detailed profiling deferred to v1.2

## Logging Questions

### Q4: Log File Path Privacy

**Question**: Should we hash file paths in logs or just log filename?

**Answer**: **Log filename only** (not full path)

**Rationale**:
- Filename is sufficient for debugging
- Full path may contain PII (user directories, etc.)
- Full path available in DEBUG level if needed
- Simpler implementation

**Implementation**:
- Log format: `"file": "sample.exe"` (filename only)
- DEBUG level: `"file_path": "/app/workspace/sample.exe"` (full path)

### Q5: Prometheus Integration

**Question**: Should we integrate Prometheus in v1.1?

**Answer**: **Defer to v1.2**

**Rationale**:
- Keep v1.1 focused on core observability (logging)
- Prometheus requires additional infrastructure
- Basic metrics in logs sufficient for v1.1
- Can add Prometheus exporter in v1.2

## Error Handling Questions

### Q6: Structured Errors - Default vs Optional

**Question**: Should structured errors be default or optional?

**Answer**: **Optional (default: string format)**

**Rationale**:
- Maintain backward compatibility with existing AI agents
- Allow gradual migration
- Some agents may prefer simple string errors
- Opt-in via `STRUCTURED_ERRORS=true` env var

**Implementation**:
- Default: Return error string (current behavior)
- Optional: Set `STRUCTURED_ERRORS=true` for JSON error responses
- Both formats include error codes for consistency

## r2pipe Questions

### Q7: r2pipe Connection Pooling

**Question**: Should we implement connection pooling in v1.1?

**Answer**: **Defer to v1.2**

**Rationale**:
- Adds significant complexity (connection lifecycle management)
- v1.1 focuses on basic r2pipe integration with timeout
- Pooling can be added later without breaking changes
- Current opt-in approach is sufficient

**Implementation for v1.1**:
- Each `run_radare2` call creates new r2pipe connection
- Connection closed after command execution
- Pooling deferred to v1.2 for performance optimization

### Q8: r2pipe Use Case Guidelines

**Question**: When should users use r2pipe vs subprocess?

**Answer**: Provide clear guidelines in documentation

**Recommendations**:
- **Use r2pipe when**:
  - Executing multiple sequential radare2 commands
  - Need to maintain r2 session state
  - Performance is critical (20%+ improvement expected)

- **Use subprocess when**:
  - Single command execution
  - Stability is priority
  - r2pipe unavailable or fails

## LIEF Questions

### Q9: LIEF Memory Safety

**Question**: Does LIEF handle large binaries safely? Do we need memory limits?

**Answer**: **Add 1GB size limit check for safety**

**Rationale**:
- LIEF generally handles large binaries well
- But very large binaries (multi-GB) can cause issues
- Proactive limit prevents OOM
- Can be adjusted via environment variable

**Implementation**:
- Check file size before parsing: `max_size = 1_000_000_000` (1GB)
- Return error if file exceeds limit
- Configurable via `LIEF_MAX_FILE_SIZE` env var

## API Documentation Questions

### Q10: FastMCP Swagger UI Support

**Question**: Does FastMCP provide Swagger UI by default?

**Answer**: **Likely yes (FastAPI-based), but may need manual setup**

**Rationale**:
- FastMCP is built on FastAPI
- FastAPI provides `/docs` endpoint by default
- May need to verify and configure if needed
- Check FastMCP documentation for specifics

**Implementation**:
- Test if `/docs` endpoint works out of the box
- If not, add manual Swagger UI configuration
- Document in README

## Rate Limiting Questions

### Q11: Rate Limiting for Stdio Mode

**Question**: Is rate limiting needed for stdio mode?

**Answer**: **No - HTTP mode only**

**Rationale**:
- Stdio mode is single-client (one AI agent)
- No network-based DoS risk
- Rate limiting unnecessary overhead
- HTTP mode has multiple clients, needs protection

**Implementation**:
- Rate limiting middleware only active in HTTP mode
- Check `MCP_TRANSPORT == "http"` before applying limits

## CI/CD Questions

### Q12: Test Sample Binary Management in CI

**Question**: Should we commit test binaries to Git or generate them in CI?

**Answer**: **Commit small binaries, generate large ones in CI**

**Rationale**:
- Small binaries (< 1MB): Commit to Git for fast CI
- Large binaries (> 1MB): Generate in CI to avoid repo bloat
- Self-generated binaries avoid copyright issues
- Use Docker image binaries (`/bin/ls`, `/bin/cat`) as fallback

**Implementation**:
- Commit: `hello_world.elf`, `hello_world.exe` (< 100KB each)
- Generate in CI: Large test files (1GB) using `dd` or similar
- Use system binaries: `/bin/ls`, `/bin/cat` from Docker image

## Summary of Decisions

| Question | Decision | Rationale |
|----------|----------|-----------|
| Path validation | `os.path.commonpath()` | More robust, Python 3.5+ compatible |
| Large file tests | Basic in v1.1, profiling in v1.2 | Balance coverage vs CI time |
| Log file paths | Filename only | Privacy protection, simpler |
| Prometheus | Defer to v1.2 | Keep v1.1 focused |
| Structured errors | Optional (default: string) | Backward compatibility |
| r2pipe pooling | Defer to v1.2 | Complexity vs benefit |
| LIEF memory limit | 1GB limit check | Safety precaution |
| Rate limiting | HTTP mode only | Stdio doesn't need it |
| Test binaries | Commit small, generate large | Balance speed vs repo size |

## Approved Plan

All technical decisions have been reviewed and approved. The v1.1 development plan is ready for execution.

